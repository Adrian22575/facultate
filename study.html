<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Studiu</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="assets/styles.css">
</head>
<body>
  <div class="container">
    <a class="btn-back" id="backLink" href="index.html">Ãnapoi</a>

    <h1 id="title">Mod Studiu</h1>

    <div class="study-intro">
      <h3>ğŸ“– Mod Studiu</h3>
      <p>StudiazÄƒ toate Ã®ntrebÄƒrile, cu rÄƒspunsurile corecte evidenÈ›iate.</p>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div id="progressText" style="font-weight:700; color:#555;">Progres: 0 din 0 Ã®ntrebÄƒri vizualizate</div>
    </div>

    <div id="questionsRoot"></div>
  </div>

  <script>
    function getParam(name) {
      return new URLSearchParams(location.search).get(name);
    }

    function normalizeQuestions(raw) {
      const arr = Array.isArray(raw) ? raw : (raw.questions || []);
      return arr.map((q, idx) => ({
        id: q.id ?? (idx + 1),
        text: q.text ?? q.q ?? "",
        answers: q.answers ?? q.options ?? [],
        correctIndex: (q.correctIndex ?? q.correct),
        difficulty: q.difficulty ?? 1
      })).filter(q =>
        q.text &&
        Array.isArray(q.answers) &&
        q.answers.length &&
        Number.isInteger(q.correctIndex)
      );
    }

    async function init() {
      // 1) subjectId din URL, fallback la ultima materie (ca sÄƒ nu rÄƒmÃ¢i blocat)
      let subjectId = getParam("subject") || localStorage.getItem("lastSubjectId");
      const backEl = document.getElementById("backLink");

      if (subjectId) {
        // salveazÄƒ mereu ultima materie folositÄƒ
        localStorage.setItem("lastSubjectId", subjectId);
        backEl.href = `subject.html?subject=${encodeURIComponent(subjectId)}`;
      } else {
        // fallback: dacÄƒ nu È™tim materia, Ã®ncearcÄƒ history.back()
        backEl.href = "#";
        backEl.addEventListener("click", (e) => {
          e.preventDefault();
          if (history.length > 1) history.back();
          else location.href = "index.html";
        });
        throw new Error("LipseÈ™te parametrul ?subject= (È™i nu existÄƒ lastSubjectId).");
      }

      // 2) ia titlul + fiÈ™ierul de Ã®ntrebÄƒri
      const sRes = await fetch("data/subjects.json", { cache: "no-store" });
      if (!sRes.ok) throw new Error("Nu pot Ã®ncÄƒrca data/subjects.json");
      const sData = await sRes.json();

      const subject = (sData.subjects || []).find(s => s.id === subjectId);
      if (!subject) throw new Error("Materia nu existÄƒ Ã®n subjects.json: " + subjectId);

      document.title = `Studiu â€” ${subject.title}`;
      document.getElementById("title").textContent = `Mod Studiu â€” ${subject.title}`;

      const qRes = await fetch(subject.questionsFile, { cache: "no-store" });
      if (!qRes.ok) throw new Error("Nu pot Ã®ncÄƒrca Ã®ntrebÄƒrile: " + subject.questionsFile);
      const rawQ = await qRes.json();

      const questions = normalizeQuestions(rawQ);
      if (!questions.length) throw new Error("FiÈ™ierul de Ã®ntrebÄƒri e gol sau format greÈ™it.");

      // 3) render
      const root = document.getElementById("questionsRoot");
      root.innerHTML = "";

      questions.forEach((q, idx) => {
        const card = document.createElement("div");
        card.className = "question-study";
        card.dataset.index = String(idx);

        const h = document.createElement("h3");
        h.textContent = `${idx + 1}. ${q.text}`;
        card.appendChild(h);

        const ul = document.createElement("ul");
        ul.className = "options-study";

        q.answers.forEach((ans, i) => {
          const li = document.createElement("li");
          li.textContent = ans;
          if (i === q.correctIndex) li.classList.add("correct");
          ul.appendChild(li);
        });

        card.appendChild(ul);
        root.appendChild(card);
      });

      // 4) progres pe scroll
      const seen = new Set();
      const fill = document.getElementById("progressFill");
      const txt = document.getElementById("progressText");

      function updateProgress() {
        const total = questions.length;
        const viewed = seen.size;
        const pct = total ? Math.round((viewed / total) * 100) : 0;
        fill.style.width = pct + "%";
        txt.textContent = `Progres: ${viewed} din ${total} Ã®ntrebÄƒri vizualizate`;
      }

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(e => {
          if (e.isIntersecting) {
            seen.add(e.target.dataset.index);
            updateProgress();
          }
        });
      }, { threshold: 0.6 });

      document.querySelectorAll(".question-study").forEach(el => observer.observe(el));
      updateProgress();
    }

    init().catch(err => {
      console.error(err);
      document.getElementById("questionsRoot").innerHTML =
        `<div style="color:#b00020; font-weight:800;">${err.message}</div>`;
    });
  </script>
</body>
</html>
